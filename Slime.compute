// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateActor
#pragma kernel UpdateTrailsHorizontal
#pragma kernel UpdateTrailsVertical
#pragma kernel DrawFieldBoundary


struct Actor
{
    int species;
    float2 position;
    float angle;
};

struct Species
{
    int index;
    float sensorSize;
    float sensorAngle;
    float sensorDistance;
    float moveSpeed;
    float turnSpeed;
    float4 color;
    float4 inverseColor;
};

struct Settings
{
    float2 sensorSizeRange;
    float2 sensorAngleRange;
    float2 sensorDistanceRange;
    float2 moveSpeedRange;
    float2 turnSpeedRange;
};

int resolution;

float deltaTime;
float time;

float evaporateSpeed;

RWStructuredBuffer<Actor> actors;

StructuredBuffer<Species> species;

StructuredBuffer<Settings> settingsBuffer;

RWTexture2D<float4> _drawTex;

Texture2D _trailTexToSample;
SamplerState sampler_trailTexToSample;

RWTexture2D<float4> _trailTexToWrite;
RWTexture2D<float4> _trailTexToWrite2;

float4 sensorSizeRange;
float4 sensorAngleRange;
float4 sensorDistanceRange;
float4 moveSpeedRange;
float4 turnSpeedRange;


float PI = 3.1415926535;

// Hash function from H. Schechter & R. Bridson, goo.gl/RXiKaH
uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

//from https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/
uint pcg_hash(uint input)
{
    uint state = input * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float Random(uint seed)
{
    //return float(Hash(seed)) / 4294967295.0; // 2^32-1
    return float(pcg_hash(seed)) / 4294967295.0;
}


float2 getOffset(float angle, float distance)
{
    return float2(
        cos(angle) * distance,
        sin(angle) * distance
    );
}

float4 sensorSample(int2 position, int size)
{
    float4 sum = float4(0, 0, 0, 0);
    int samplesTaken = 0;
    int2 currentSampleOffset = int2(-size, -size);
    while (true)
    {
        int2 currentSamplePosition = position + currentSampleOffset;
        
        //only sample within the image
        if (currentSamplePosition.y >= 0 &&
            currentSamplePosition.y <= resolution &&
            currentSamplePosition.x >= 0 &&
            currentSamplePosition.x <= resolution)
        {
            sum += _trailTexToWrite[currentSamplePosition];
            samplesTaken++;
        }
        
        currentSampleOffset.x++;
        
        if (currentSampleOffset.x > size)
        {
            currentSampleOffset.x = -size;
            currentSampleOffset.y++;
        }
        
        if (currentSampleOffset.y > size)
        {
            float4 result = sum / samplesTaken;
            return result;
        }
    }
    
    //hopefully not
    return sum;
}

[numthreads(16,1,1)]
void UpdateActor (uint3 id : SV_DispatchThreadID)
{
    Actor a = actors[id.x];

    Species s = species[a.species];
    
    Settings settings = settingsBuffer[0];
    
    int sensorSize = (int) floor(s.sensorSize * settings.sensorSizeRange.y + settings.sensorSizeRange.x);
    float sensorAngle = s.sensorAngle * settings.sensorAngleRange.y + settings.sensorAngleRange.x;
    float sensorDistance = s.sensorDistance * settings.sensorDistanceRange.y + settings.sensorDistanceRange.x;
    float moveSpeed = s.moveSpeed * settings.moveSpeedRange.y + settings.moveSpeedRange.x;
    float turnSpeed = s.turnSpeed * settings.turnSpeedRange.y + settings.turnSpeedRange.x;
    
    float2 centerSensorPos = getOffset(a.angle, sensorDistance) + a.position;
    float2 leftSensorPos = getOffset(a.angle + sensorAngle, sensorDistance) + a.position;
    float2 rightSensorPos = getOffset(a.angle - sensorAngle, sensorDistance) + a.position;
    
    float4 centerSensorOutput = sensorSample(centerSensorPos, sensorSize);
    float centerValue = dot(centerSensorOutput * s.color, float4(1, 1, 1, 1)) - dot(centerSensorOutput * s.inverseColor, float4(1,1,1,1))/2;
    float4 leftSensorOutput = sensorSample(leftSensorPos, sensorSize);
    float leftValue = dot(leftSensorOutput * s.color, float4(1, 1, 1, 1)) - dot(leftSensorOutput * s.inverseColor, float4(1, 1, 1, 1))/2;
    float4 rightSensorOutput = sensorSample(rightSensorPos, sensorSize);
    float rightValue = dot(rightSensorOutput * s.color, float4(1, 1, 1, 1)) - dot(rightSensorOutput * s.inverseColor, float4(1, 1, 1, 1))/2;
    uint seed = (uint) id.x + a.position.x + a.position.y + time;
    if (leftValue >= centerValue && leftValue > rightValue)
    {
        a.angle += turnSpeed * deltaTime * Random(seed) * 3;
    }
    else if (rightValue >= centerValue && rightValue > leftValue)
    {
        a.angle -= turnSpeed * deltaTime * Random(seed) * 3;
    }
    else
    {
        a.angle += (Random(seed) - 0.5) * 0.5 * turnSpeed * deltaTime;
    }
    
    float2 movement = getOffset(a.angle, moveSpeed * deltaTime);

    a.position = a.position + movement;

    /* bounce off edges
    if (a.position.x > resolution || a.position.x < 0)
    {
        a.angle = acos(-(normalize(movement).x));
    }
    if (a.position.y > resolution || a.position.y < 0)
    {
        a.angle = -a.angle;
    }
    */
    
    if (a.position.x > resolution || a.position.x < 0 || a.position.y > resolution || a.position.y < 0)
    {
        a.angle = (Random(seed + id.x + time)) * 360;
    }
    
    float2 center = float2(resolution / 2., resolution / 2.);
    float radiusSquared = (resolution / 2) * (resolution / 2);
    float distanceSquaredFromCenter = dot(a.position - center, a.position - center);
    
    float turnBackDistance = max(distanceSquaredFromCenter - radiusSquared, 0);
    
    float turnBackDirection = saturate(max(dot(a.position - center, movement), 0));
    
    float turnBackWeight = 0.05;
    
    a.angle += (turnBackWeight * turnBackDirection * turnBackDistance) * turnSpeed * deltaTime;
    
    
    

    a.position = clamp(a.position, float2(0, 0), float2(resolution, resolution));
    int2 texturePosition = int2(floor(a.position.x), floor(a.position.y));
    
    actors[id.x] = a;

    _trailTexToWrite[texturePosition] += s.color;
    _trailTexToWrite2[texturePosition] += s.color;
}

[numthreads(8, 8, 1)]
void UpdateTrailsHorizontal (uint3 id : SV_DispatchThreadID)
{    
    float otherKernel[7] =
    {
        0.001,
        0.01,
        0.2,
        4.,
        0.2,
        0.01,
        0.001
    };
    
    float4 sum = float4(0, 0, 0, 0);
    
    for (int x = 0; x < 7; x++)
    {
        float2 uv = float2(id.x + 0.5 + (x - 3), id.y + 0.5) / (float) resolution;
        sum += (_trailTexToSample.SampleLevel(sampler_trailTexToSample, uv, 0)) * otherKernel[x];
    }
    
    float4 col = sum / 4.422;
    //col.g = _trailTexToWrite[id.xy].g;
    
    _trailTexToWrite[id.xy] = col;
}

[numthreads(8, 8, 1)]
void UpdateTrailsVertical(uint3 id : SV_DispatchThreadID)
{
    float otherKernel[7] =
    {
        0.001,
        0.01,
        0.2,
        4.,
        0.2,
        0.01,
        0.001
    };
    
    float4 sum = float4(0, 0, 0, 0);
    
    for (int y = 0; y < 7; y++)
    {
        float2 uv = float2(id.x + 0.5, id.y + (y - 3) + 0.5) / (float) resolution;
        sum += (_trailTexToSample.SampleLevel(sampler_trailTexToSample, uv, 0)) * otherKernel[y];
    }
    
    float4 col = sum / 4.422;
    
    col -= ((1. / evaporateSpeed) * deltaTime);
    
    col.a = 1.;
    
    //col.g = _trailTexToWrite[id.xy].g;
    _trailTexToWrite[id.xy] = col;
}

[numthreads(8,8,1)]
void DrawFieldBoundary(uint3 id : SV_DispatchThreadID)
{
    float2 center = float2(resolution / 2., resolution / 2.);
    float radiusSquared = (resolution / 2) * (resolution / 2);
    float distanceSquaredFromCenter = dot(id.xy - center, id.xy - center);
    
    float4 color = float4(0, max(distanceSquaredFromCenter - radiusSquared, 0), 0, 1);
    color = saturate(color);
    
    _trailTexToWrite[id.xy] = color;
    _trailTexToWrite2[id.xy] = color;
}


